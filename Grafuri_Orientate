#include <bits/stdc++.h>
using namespace std;
struct Graf
{
    int  cost, muchie;
};

class Grafuri_Orientate
{
private:
    Graf a[103][103];
    int n, m, d[103], viz[103], pred[103];
    int de[103], di[103]; ///Grad extern si intern
    int v[100003], len = 0 ; ///Topologic
    int nrctc = 0;
    const int oo = 1e9;
public:
    Grafuri_Orientate(const char fisIn[])
    {
        ifstream fin(fisIn);
        int i, j, c;
        fin >> n >> m;
        for(int p = 1; p <= m; p++)
        {
            fin >> i >> j >> c;
            a[i][j].muchie = 1; 
            a[i][j].cost = c;
        }
        fin.close();
    }

    void AddMuchie(int i, int j)
    {
        a[i][j].muchie = 1;
    }

    void Grade()
    {
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
        {
            if(a[i][j].muchie)
                di[i] += a[i][j].muchie;
            if(a[j][i].muchie)
                de[i] += a[j][i] .muchie;
        }
    }

    Grafuri_Orientate& operator=(const Grafuri_Orientate& B)
    {
        n = B.n;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                a[i][j] = B.a[i][j];
        return *this;
    }

    int Size()
    {
        return n;
    }

    void Clear()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                a[i][j].muchie = a[i][j].cost = d[j] = viz[j] = 0;
    }

    void Reset()
    {
        for(int i = 1; i <= n; i++)
            viz[i] = d[i] = 0;
    }

    void BFS(int k)
    {
        int q[103], ul, pr;
        pr = ul = 1; q[ul] = k;
        d[k] = 0; viz[k] = 1;
        while(pr <= ul)
        {
            k = q[pr++];
            for(int i = 1; i <= n; i++)
                if(a[k][i].muchie && !viz[i])
                {
                    viz[i] = 1;
                    q[++ul] = i;
                    d[i] = d[k] + 1;
                }
        }
    }

    void DFS(int k)
    {
        viz[k] = 1;
        for (int i = 1; i <= n; i++)
            if (!viz[i] && a[k][i].muchie) 
                DFS(i);
        v[++len] = k;
    }

    void DFS1(int k)
    {
        viz[k] = nrctc;
        for (int i = 1; i <= n; i++)
            if (!viz[i] && a[k][i].muchie) 
                DFS1(i);
    }

    void Verificare()
    {
        for(int i = 1; i <= n; i++)
            if(viz[i]) 
                cout << i << " ";
        cout << "\n";
    }

    int Vizitate()
    {
        for(int i = 1; i <= n; i++)
            if(viz[i] == 0) return 0; 
        return 1;
    }

    void AfisMatriceFaraCost()
    {
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
                cout << a[i][j].muchie << " ";
            cout << "\n";
        }
    }

    void AfisMatriceCost()
    {
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
                cout << a[i][j].cost << " ";
            cout << "\n";
        }
    }

    void SortTop()
    {
        for(int i = 1; i <= n; i++)
            if(!viz[i]) 
                DFS(i);
    }

    void AfisTopologic()
    {
        for(int i = n; i >= 1; i--)
            cout << v[i] << " ";
        cout << "\n";
    }

    void AfisParcurgeri()
    {
        int viz = 0;
        for(int i = 1; i <= n; i++)
        {
            DFS(i);
            if(Vizitate()) 
            {
                cout << i << " ";
                viz = 1;
            }   
            Reset();
        }
        if(viz == 0) cout << "Nu sunt noduri ce pot vizita toate celelalte nodurui";
        cout << "\n";
    }

    void AfisGrade()
    {
        Grade();
        cout << "Grade externe ";
        for(int i = 1; i <= n; i++)
            cout << de[i] << " ";
        cout << "\n" << "Grade interne ";
        for(int i = 1; i <= n; i++)
            cout << di[i] << " ";
        cout << "\n";
    }

    void MersCircuite(int i, int j)
    {
    for(int k = 1; k <= n; k++)
        if(a[j][k].muchie == 1 && a[k][i].muchie == 1)
            cout << i << " " << j << " " << k << "\n";
    }

    void AfisCircuite()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(a[i][j].muchie)
                    MersCircuite(i, j);
    }

    void MersCicluri(int i, int j)
    {
        for(int k = 1; k <= n; k++)
            if((a[i][k].muchie == 1 || a[k][i].muchie == 1) && (a[k][j].muchie == 1 || a[j][k].muchie == 1))
                cout << i << " " << j << " " << k << "\n";
    }

    void AfisCicluri()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(a[i][j].muchie || a[j][i].muchie)
                    MersCicluri(i, j);
    }

    void AfisVPrietene()
    {
        int d1 = 0, d2= 0, cnt = 0;
        for(int i = 1; i <= n; i++)
            for(int j = 1 + i; j <= n; j++)
            {
                BFS(i);
                d1 = d[j];
                Reset();
                BFS(j);
                d2 = d[i];
                if(d1 == d2 && d1 != 0){
                    cnt = 1;
                    cout << i << " " << j << "\n";
                }
                Reset();
            }
        if(cnt == 0)
            cout << "Nu exista" << "\n";
    }

    void Kosaraju()
    {
        SortTop();
        Reset();
        for (int i = n; i >= 1; i--)
            if (viz[v[i]] == 0)
            {
                nrctc++;
                DFS1(v[i]);
            }
    }

    void AfisTC()
    {
        Kosaraju();
        cout << nrctc << "\n";
    }

    void AfisArceInutile()
    {
        
        int cnt = 0;
        for (int k = 1; k <= n; k++)
            for (int i = 1; i <= n; i++)
                if (viz[k] != viz[i]) cnt++;
        cout << cnt << "\n";
        for (int k = 1; k <= n; k++)
            for (int i = 1; i <= n; i++)
                if (viz[k] != viz[i])
                    cout << k << " " << i << "\n";
    }

    void Dijkstra(int k)
    {
        int i, mn;
        /// initial
        Reset();
        for (i = 1; i <= n; i++)
        {
            d[i] = oo;
            viz[i] = pred[i] = 0;
        }
        d[k] = 0;
        /// cel mult n pasi
        for (int pas = 1; pas <= n; pas++)
        {
            /// aflam nodul k nevizitat cu d[k]=minim
            k = 0; mn = oo;
            for (i = 1; i <= n; i++)
                if (!viz[i] && d[i] < mn)
                {
                    mn = d[i];
                    k = i;
                }
            if (d[k] == oo) return;
            viz[k] = 1;
            for (i = 1; i <= n; i++)
                if (a[k][i].cost < oo && a[k][i].cost > 0 && d[i] > d[k] + a[k][i].cost)
                {
                    d[i] = d[k] + a[k][i].cost;
                    pred[i] = k;
                }
        }
    }
};


int main()
{
    
    return 0;
}
