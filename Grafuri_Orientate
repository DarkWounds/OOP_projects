#include <iostream>
#include <fstream>
#define Marime 200000

using namespace std;

class Grafuri_Orientate
{
private:
    int a[Marime][Marime];
    int n, m, d[Marime], viz[Marime], pred[Marime];
    int de[Marime], di[Marime]; ///Grad extern si intern
    int v[Marime], len = 0 ; ///Topologic
    int nrctc = 0;/// Nr componente conexe
public:
    Grafuri_Orientate(const char fisIn[])
    {
        ifstream fin(fisIn);
        int i, j;
        fin >> n >> m;
        for(int p = 1; p <= m; p++)
        {
            fin >> i >> j;
            a[i][j] = 1; 
        }
        fin.close();
    }

    void Citire();
    void AddMuchie(int i, int j);
    void StergeMuchie(int i, int j);
    void Grade();
    int Size();
    void Clear();
    void Reset();
    void BFS(int k);
    void DFS(int k);
    void DFS1(int k);
    void Verificare();
    int Vizitate();
    void AfisMatrice();
    void SortTop();
    void AfisTopologic();
    void AfisParcurgeri();
    void AfisArceInutile();
    void AfisTC();
    void AfisVPrietene();
    void AfisCicluri();
    void AfisGrade();
    void MersCircuite(int i, int j);
    void AfisCircuite();
    void MersCicluri(int i, int j);

    Grafuri_Orientate& operator=(const Grafuri_Orientate& B)
    {
        n = B.n;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                a[i][j] = B.a[i][j];
        return *this;
    }

};

    int Grafuri_Orientate::Size()
    {
        return n;
    }

    void Grafuri_Orientate::Clear()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                a[i][j] = d[j] = viz[j] = 0;
    }

    void Grafuri_Orientate::Reset()
    {
        for(int i = 1; i <= n; i++)
            viz[i] = d[i] = 0;
    }

    void Grafuri_Orientate::BFS(int k)
    {
        int q[103], ul, pr;
        pr = ul = 1; q[ul] = k;
        d[k] = 0; viz[k] = 1;
        while(pr <= ul)
        {
            k = q[pr++];
            for(int i = 1; i <= n; i++)
                if(a[k][i] && !viz[i])
                {
                    viz[i] = 1;
                    q[++ul] = i;
                    d[i] = d[k] + 1;
                }
        }
    }

    void Grafuri_Orientate::DFS(int k)
    {
        viz[k] = 1;
        for (int i = 1; i <= n; i++)
            if (!viz[i] && a[k][i]) 
                DFS(i);
        v[++len] = k;
    }

    void Grafuri_Orientate::DFS1(int k)
    {
        viz[k] = nrctc;
        for (int i = 1; i <= n; i++)
            if (!viz[i] && a[k][i]) 
                DFS1(i);
    }

    void Grafuri_Orientate::Verificare()
    {
        for(int i = 1; i <= n; i++)
            if(viz[i]) 
                cout << i << " ";
        cout << "\n";
    }

    int Grafuri_Orientate::Vizitate()
    {
        for(int i = 1; i <= n; i++)
            if(viz[i] == 0) return 0; 
        return 1;
    }

    void Grafuri_Orientate::AfisMatrice()
    {
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= n; j++)
                cout << a[i][j] << " ";
            cout << "\n";
        }
    }

    void Grafuri_Orientate::SortTop()
    {
        for(int i = 1; i <= n; i++)
            if(!viz[i]) 
                DFS(i);
    }

    void Grafuri_Orientate::AfisTopologic()
    {
        for(int i = n; i >= 1; i--)
            cout << v[i] << " ";
        cout << "\n";
    }

    void Grafuri_Orientate::AfisParcurgeri()
    {
        int viz = 0;
        for(int i = 1; i <= n; i++)
        {
            DFS(i);
            if(Vizitate()) 
            {
                cout << i << " ";
                viz = 1;
            }   
            Reset();
        }
        if(viz == 0) cout << "Nu sunt noduri ce pot vizita toate celelalte nodurui";
        cout << "\n";
    }

    void Grafuri_Orientate::AfisGrade()
    {
        Grade();
        cout << "Grade externe ";
        for(int i = 1; i <= n; i++)
            cout << de[i] << " ";
        cout << "\n" << "Grade interne ";
        for(int i = 1; i <= n; i++)
            cout << di[i] << " ";
        cout << "\n";
    }

    void Grafuri_Orientate::MersCircuite(int i, int j)
    {
    for(int k = 1; k <= n; k++)
        if(a[j][k] == 1 && a[k][i] == 1)
            cout << i << " " << j << " " << k << "\n";
    }

    void Grafuri_Orientate::AfisCircuite()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(a[i][j])
                    MersCircuite(i, j);
    }

    void Grafuri_Orientate::MersCicluri(int i, int j)
    {
        for(int k = 1; k <= n; k++)
            if((a[i][k] == 1 || a[k][i] == 1) && (a[k][j] == 1 || a[j][k] == 1))
                cout << i << " " << j << " " << k << "\n";
    }

    void Grafuri_Orientate::AfisCicluri()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(a[i][j] || a[j][i])
                    MersCicluri(i, j);
    }

    void Grafuri_Orientate::AfisVPrietene()
    {
        int d1 = 0, d2= 0, cnt = 0;
        for(int i = 1; i <= n; i++)
            for(int j = 1 + i; j <= n; j++)
            {
                BFS(i);
                d1 = d[j];
                Reset();
                BFS(j);
                d2 = d[i];
                if(d1 == d2 && d1 != 0){
                    cnt = 1;
                    cout << i << " " << j << "\n";
                }
                Reset();
            }
        if(cnt == 0)
            cout << "Nu exista" << "\n";
    }

    void Grafuri_Orientate::AfisArceInutile()
    {
        
        int cnt = 0;
        for (int k = 1; k <= n; k++)
            for (int i = 1; i <= n; i++)
                if (viz[k] != viz[i]) cnt++;
        cout << cnt << "\n";
        for (int k = 1; k <= n; k++)
            for (int i = 1; i <= n; i++)
                if (viz[k] != viz[i])
                    cout << k << " " << i << "\n";
    }

    void Grafuri_Orientate::Citire()
    {
        int i, j, c;
        cin >> n >> m;
        for(int p = 1; p <= m; p++)
        {
            cin >> i >> j;
            a[i][j] = 1; 
        }   
    }

    void Grafuri_Orientate::AddMuchie(int i, int j)
    {
        a[i][j] = 1;
    }

    void Grafuri_Orientate::StergeMuchie(int i, int j)
    {
        a[i][j] = 0;
    }

    void Grafuri_Orientate::Grade()
    {
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
            {
                if(a[i][j])
                    di[i] += a[i][j];
                if(a[j][i])
                    de[i] += a[j][i];
            }
    }

int main()
{
    
    return 0;
}
